## B+ 树

![image-20210317190013980](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20210317190013980.png)

### B树

![image-20210317190111828](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20210317190111828.png)



一 ：在B+树中，具有n个关键字的结点含有n个分支;而在B树中，具有n个关键字的结点含有n+1个分支。



二： 在B+树中叶子结点包含信息，并且包含了全部关键字，叶子结点引出的指针指向记录。



三：B+树中所有非叶子结点仅仅起到一个索引的作用，即结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，

​		不含有该关键字对应记录的存储地址；

​		在B树中，每个关键字对应一个存记录的存储地址；

四：在B+树上有一个指针指向关键字最小的叶子结点，所有叶子结点链接成一个线性链表，而B-树没有。



### 1 B树

在介绍B+树之前， 先简单的介绍一下B树，这两种数据结构既有相似之处，也有他们的区别，最后，我们也会对比一下这两种数据结构的区别。

#### 1.1 B树概念

B树也称B-树,它是一颗多路平衡查找树。二叉树我想大家都不陌生，其实，B树和后面讲到的B+树也是从最简单的二叉树变换而来的，并没有什么神秘的地方，下面我们来看看B树的定义。

- 每个节点最多有m-1个**关键字**（可以存有的键值对）。
- 根节点最少可以只有1个**关键字**。
- 非根节点至少有m/2个**关键字**。
- 每个节点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。
- 所有叶子节点都位于同一层，或者说根节点到每个叶子节点的长度都相同。
- 每个节点都存有索引和数据，也就是对应的key和value。

所以，根节点的**关键字**数量范围：`1 <= k <= m-1`，非根节点的**关键字**数量范围：`m/2 <= k <= m-1`。

另外，我们需要注意一个概念，描述一颗B树时需要指定它的阶数，阶数表示了一个节点最多有多少个孩子节点，一般用字母m表示阶数。

我们再举个例子来说明一下上面的概念，比如这里有一个5阶的B树，根节点数量范围：1 <= k <= 4，非根节点数量范围：2 <= k <= 4。

下面，我们通过一个插入的例子，讲解一下B树的插入过程，接着，再讲解一下删除关键字的过程。

#### 1.2 B树插入

插入的时候，我们需要记住一个规则：**判断当前结点key的个数是否小于等于m-1，如果满足，直接插入即可，如果不满足，将节点的中间的key将这个节点分为左右两部分，中间的节点放到父节点中即可。**

例子：在5阶B树中，结点最多有4个key,最少有2个key（注意：下面的节点统一用一个节点表示key和value）。

- 插入18，70，50,40

![img](https://oscimg.oschina.net/oscnet/eb191e52c4af046dc6d858c793c8ddf3c8e.jpg)

- 插入22

![img](https://oscimg.oschina.net/oscnet/0c6e169e37ff9643c46c72922f42bcb5d46.jpg)

插入22时，发现这个节点的关键字已经大于4了，所以需要进行分裂，分裂的规则在上面已经讲了，分裂之后，如下。

![img](https://oscimg.oschina.net/oscnet/1377e97a1160e07ffa600c0d8cba7cadf1e.jpg)

- 接着插入23，25，39

![img](https://oscimg.oschina.net/oscnet/03e1e510bcd8672a98e1a67dd60a91d3aea.jpg)

分裂，得到下面的。

![img](https://oscimg.oschina.net/oscnet/1155825270844bbe53c9f2701395c3fa9af.jpg)

更过的插入的过程就不多介绍了，相信有这个例子你已经知道怎么进行插入操作了。

#### 1.3 B树的删除操作

B树的删除操作相对于插入操作是相对复杂一些的，但是，你知道记住几种情况，一样可以很轻松的掌握的。

- 现在有一个初始状态是下面这样的B树，然后进行删除操作。

![img](https://oscimg.oschina.net/oscnet/261678b789a5f4dac373093919ea6a41b8a.jpg)

- 删除15，这种情况是删除叶子节点的元素，如果删除之后，节点数还是大于`m/2`，这种情况只要直接删除即可。

![img](https://oscimg.oschina.net/oscnet/0ed340c43b270b4a7932d7db15ebf0acc26.jpg)

![img](https://oscimg.oschina.net/oscnet/11e2970a52f2b9c73b2a30922b623d4e380.jpg)

- 接着，我们把22删除，这种情况的规则：22是非叶子节点，**对于非叶子节点的删除，我们需要用后继key（元素）覆盖要删除的key，然后在后继key所在的子支中删除该后继key**。对于删除22，需要将后继元素24移到被删除的22所在的节点。

![img](https://oscimg.oschina.net/oscnet/6343b9be4ff09d04096e9eac1d500ba0e9d.jpg)

![img](https://oscimg.oschina.net/oscnet/c60eb3ba1f5fac64515eccfc03192f40fdb.jpg)

此时发现26所在的节点只有一个元素，小于2个（m/2），这个节点不符合要求，这时候的规则（向兄弟节点借元素）：**如果删除叶子节点，如果删除元素后元素个数少于（m/2），并且它的兄弟节点的元素大于（m/2），也就是说兄弟节点的元素比最少值m/2还多，将先将父节点的元素移到该节点，然后将兄弟节点的元素再移动到父节点**。这样就满足要求了。

我们看看操作过程就更加明白了。

![img](https://oscimg.oschina.net/oscnet/853a8ead34267d029e8d984958c8d4dbea8.jpg)

![img](https://oscimg.oschina.net/oscnet/0ac5a97219474c5fc16270314e655bf0437.jpg)

- 接着删除28，**删除叶子节点**，删除后不满足要求，所以，我们需要考虑向兄弟节点借元素，但是，兄弟节点也没有多的节点（2个），借不了，怎么办呢？如果遇到这种情况，**首先，还是将先将父节点的元素移到该节点，然后，将当前节点及它的兄弟节点中的key合并，形成一个新的节点**。

![img](https://oscimg.oschina.net/oscnet/e5845ae0ae2fe779a932aa452ce650a4b48.jpg)

移动之后，跟兄弟节点合并。

![img](https://oscimg.oschina.net/oscnet/2dfa4b4474986a121c404f2b7b89579616f.jpg)

删除就只有上面的几种情况，根据不同的情况进行删除即可。

上面的这些介绍，相信对于B树已经有一定的了解了，接下来的一部分，我们接着讲解B+树，我相信加上B+树的对比，就更加清晰明了了。

### 2 B+树

#### 2.1 B+树概述

B+树其实和B树是非常相似的，我们首先看看**相同点**。

- 根节点至少一个元素
- 非根节点元素范围：m/2 <= k <= m-1

**不同点**。

- B+树有两种类型的节点：内部结点（也称索引结点）和叶子结点。内部节点就是非叶子节点，内部节点不存储数据，只存储索引，数据都存储在叶子节点。
- 内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。叶子结点中的记录也按照key的大小排列。
- 每个叶子结点都存有相邻叶子结点的指针，叶子结点本身依关键字的大小自小而大顺序链接。
- 父节点存有右孩子的第一个元素的索引。

下面我们看一个B+树的例子，感受感受它吧！

![img](https://oscimg.oschina.net/oscnet/bf4d4963b024f6c9fe44d6b26d4f27af54f.jpg)

#### 2.2 插入操作

对于插入操作很简单，只需要记住一个技巧即可：**当节点元素数量大于m-1的时候，按中间元素分裂成左右两部分，中间元素分裂到父节点当做索引存储，但是，本身中间元素还是分裂右边这一部分的**。

下面以一颗5阶B+树的插入过程为例，5阶B+树的节点最少2个元素，最多4个元素。

- 插入5，10，15，20

![img](https://oscimg.oschina.net/oscnet/00114e18a748d2a453007a8b252a43ae8a4.jpg)

- 插入25，此时元素数量大于4个了，分裂

![img](https://oscimg.oschina.net/oscnet/6869626e80377a560361d624f172e1e384f.jpg)

- 接着插入26，30，继续分裂

![img](https://oscimg.oschina.net/oscnet/0a0428579676a0b2543433cafd702029a76.jpg)

![img](https://oscimg.oschina.net/oscnet/57e93e2184d5307f303a6f846cdf900345b.jpg)

有了这几个例子，相信插入操作没什么问题了，下面接着看看删除操作。

#### 2.3 删除操作

对于删除操作是比B树简单一些的，因为**叶子节点有指针的存在，向兄弟节点借元素时，不需要通过父节点了，而是可以直接通过兄弟节移动即可（前提是兄弟节点的元素大于m/2），然后更新父节点的索引；如果兄弟节点的元素不大于m/2（兄弟节点也没有多余的元素），则将当前节点和兄弟节点合并，并且删除父节点中的key**，下面我们看看具体的实例。

- 初始状态

![img](https://oscimg.oschina.net/oscnet/365354deaff4bc75d16cf17c3255c46aca4.jpg)

- 删除10，删除后，不满足要求，发现左边兄弟节点有多余的元素，所以去借元素，最后，修改父节点索引

![img](https://oscimg.oschina.net/oscnet/685a53344454eb37d664919a42dac30a45a.jpg)

- 删除元素5，发现不满足要求，并且发现左右兄弟节点都没有多余的元素，所以，可以选择和兄弟节点合并，最后修改父节点索引

![img](https://oscimg.oschina.net/oscnet/f74ef5fff6f4489fbdcaa8d9c113eb48b26.jpg)

- 发现父节点索引也不满足条件，所以，需要做跟上面一步一样的操作

![img](https://oscimg.oschina.net/oscnet/177f38002658f2edfb39a811fed992d58b0.jpg)

这样，B+树的删除操作也就完成了，是不是看完之后，觉得非常简单！

### 3 B树和B+树总结

B+树相对于B树有一些自己的优势，可以归结为下面几点。

- 单一节点存储的元素更多，使得查询的IO次数更少，所以也就使得它更适合做为数据库MySQL的底层数据结构了。
- 所有的查询都要查找到叶子节点，查询性能是稳定的，而B树，每个节点都可以查找到数据，所以不稳定。
- 所有的叶子节点形成了一个有序链表，更加便于查找。